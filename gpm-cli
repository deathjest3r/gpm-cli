#!/usr/bin/env python

# This file is part of the gpm-cli.
#
# Copyright (C) 2013 Death Jester <d3ath.jest3r@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

import sys
import os
import argparse
import getpass
import subprocess
import errno
from select import select
import cPickle as pickle
from requests import ConnectionError
from gmusicapi import Api

class GPM:
    library = []
    api = None
    delimiter = '|'

    def __init__(self):
        self.api = self.login(self.load_config())
        self.library = self.open_library()

    def login(self, config):
        # Do the login procedure
        while True:
            try:
                api = Api()
                if api.login(config['login'], config['password'], \
                        perform_upload_auth = False):
                    return api # Succesfully logged in  
                else:
                    print "Sorry, try again."
                    raise KeyError('login')
            except KeyError as e:
                try:
                    if e.args[0] == "login":
                        config['login'] = raw_input("Login: ")
                        config['password'] = getpass.getpass()
                        continue
                    if e.args[0] == "password":
                        config['password'] = getpass.getpass()
                        continue
                    else:
                        break
                except KeyboardInterrupt:
                    sys.exit(0)
            except ConnectionError:
                print("Not able to connect to the Google service, check your"
                        "internet connection...")
                sys.exit(0)

    def open_library(self):
        try:
            # Try to open the local library if it exists
            local_lib = pickle.load(\
                    open(os.path.expanduser("~/.gpm/library.db"), "rb"))
            return local_lib
        except IOError: # Otherwise load the online lib
            online_lib = self.api.get_all_songs()
            
            try:
                os.makedirs(os.path.expanduser("~/.gpm"))
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise

            pickle.dump( online_lib, \
                    open(os.path.expanduser("~/.gpm/library.db"), "wb"))
            return online_lib

    def load_config(self):
        config = dict()
        try:
            with open(os.path.expanduser("~/.gpmrc")) as f:
                lines = f.readlines()
                for line in lines:
                    words = line.split()
                    if words[0] == 'login':
                        config['login'] = words[1]
                    elif words[0] == 'password':
                        config['password'] = words[1]
        except IOError:
            pass
        return config
   
    def get_tracks(self, title):
        artist = ''
      
        try:
            if self.delimiter in title:
                artist, title = title.split(self.delimiter)
            # Remove leading whitespaces and convert to lower case
            title = " ".join(title.split()).lower()
            artist = " ".join(artist.split()).lower()
        except Exception:
            print("Please either only specify a title or separate the artist"
                    " from the title with a '" + self.delimiter + "'")
            sys.exit(0)

        if artist == '':
            tracks = [track for track in self.library if
                (title in track['title'].lower())]
        else:
            tracks = [track for track in self.library if
                (title in track['title'].lower()) and
                (artist in track['artist'].lower())]
        return tracks

    def play(self, title):
        track = self.get_tracks(title)
        if len(track) > 1:
            print("More than one title with this name, please specify the track"
                    "with the following syntax: '<artist> | <title>'")
            sys.exit(0)
        try:
            stream_url = self.api.get_stream_url(track[0]['id'])
        except IndexError:
            print("Can't find track (use --nocache if you are "
                    "sure the track exists)")
            sys.exit(0)

        # Just call mplayer, and when 'Enter' or 'Ctrl+C' is pressed close the
        # program
        try:
            proc = subprocess.call(["mplayer", "-ao", "alsa:device=hw=1.0", \
                    "%s" % stream_url])
        except KeyboardInterrupt:
            pass

    def search(self, search):
        tracks  = [track for track in self.library if (search in track['title'])
                or (search in track['album']) or (search in track['artist'])]
        try:
            for track in tracks:
                sys.stdout.write(track["artist"] + "|" + track["title"] + "\n")
        except IndexError:
            print("Can't find track (use --sync option to update the local "
                    "library before searching)")
            sys.exit(0)

def main():
    tracks  = list()
    if select([sys.stdin], [], [], 0.0)[0]:
        while True:
            track = (sys.stdin.readline())
            if not track:
                break
            else:
                tracks.append(track)
    
    if not tracks:
        # Define the different command line arguments
        parser = argparse.ArgumentParser()
        parser.add_argument('keyword', metavar='<play|search>', type=str)
        parser.add_argument('track', type=str,
                help='specify track title to play')
        parser.add_argument('-s', '--sync', action='store_true',  
                help='sync the local library with the online mediathek')
        parser.add_argument('-l','--loop', metavar='<track|album|artist>',
                help='specify loop type, values are: track, album, artist')
        parser.add_argument('-d','--delimiter',
                help=("specify the delitmiter that separates the artist from the"
                " track title (e.g. '//' or '-', default: '|')"))

        args = parser.parse_args()

        # Throw away the local library if sync parameter given...
        if args.sync:
            try:
                local_library = os.path.expanduser("~/.gpm/library.db")
                os.remove(local_library)
            except OSError:
                print "error"
        
        #Initialize local mediathek
        gpm = GPM()

        if args.delimiter:
            gpm.delimiter = args.delimiter
        if args.keyword == "search":
            gpm.search(args.track)
        elif args.keyword == "play":
            gpm.play(args.track)

    else:
        print tracks
        for track in tracks:
            gpm = GPM()
            gpm.play(track)

if __name__ == "__main__":
    main()
